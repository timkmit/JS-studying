React — это библиотека для создания пользовательских интерфейсов. Она позволяет легко создавать динамичные приложения с большим количеством интерактивных элементов.

#### 1. **Методы создания: Create React App или Vite**

##### Create React App (CRA)
Это официальный инструмент для создания React-приложений от разработчиков React. CRA автоматически настроит сборку, транспиляцию кода и сервер для разработки.

###### Установка:
Для начала нужно установить глобально Create React App:
`npx create-react-app my-app cd my-app npm start`

Это создаст базовую структуру проекта с React, Babel, Webpack и другими инструментами.

#### Vite
Vite — это альтернативный инструмент для создания проектов на React. Он быстрее и легче, чем CRA, особенно при разработке.

###### Установка:
`npm create vite@latest my-app cd my-app npm install npm run dev`

Vite использует ES-модули для более быстрого запуска и обновления проекта.

Оба способа хорошо подходят для старта проекта, но Vite — это более современный инструмент, который особенно удобен для приложений.

#### **Функциональные компоненты**

Функциональные компоненты в React — это простые JavaScript-функции, которые возвращают JSX-разметку и могут принимать входные данные через параметры (props). Они являются основным способом написания компонентов в современных React-приложениях благодаря своей простоте и поддержке хуков, таких как `useState`, `useEffect` и т.д.

##### Пример простого функционального компонента:

```
function Welcome(props) {
  return <h1>Hello, {props.name}!</h1>;
}

export default Welcome;
```

В этом примере:

- `Welcome` — это функциональный компонент.
- `props` (от "properties") — это объект, который передает в компонент данные (в данном случае `name`).
- Компонент возвращает JSX-код, который отображает приветствие с именем.

Раньше в React использовались классовые компоненты, но функциональные компоненты стали предпочтительным способом создания компонентов благодаря хукам, которые облегчают работу с состоянием и жизненным циклом.

##### Отличия функциональных компонентов от классовых:

- Функциональные компоненты проще по структуре.
- Они не имеют методов жизненного цикла, как классовые компоненты. Вместо этого используются хуки (например, `useEffect`).
- Функциональные компоненты не имеют `this`, что упрощает работу с данными и состоянием.

#### **JSX (JavaScript XML)**

JSX — это синтаксис, который позволяет писать HTML-разметку прямо внутри JavaScript. Он выглядит как обычный HTML, но работает внутри JavaScript-кода. Это основной способ написания шаблонов в React, который делает код более читабельным и декларативным.

Когда React видит JSX, он преобразует его в вызовы `React.createElement()` под капотом. Эти вызовы создают объекты типа "React Element", которые потом рендерятся на странице.

##### Пример использования JSX:
`const element = <h1>Привет, мир!</h1>;`

Этот код возвращает HTML-элемент `<h1>Привет, мир!</h1>`, но под капотом React преобразует его в:
`const element = React.createElement('h1', null, 'Привет, мир!');`

Этот вызов создаст объект, который React использует для построения DOM:
`{   type: 'h1',   props: {     children: 'Привет, мир!'   } }`

JSX позволяет вставлять JavaScript-выражения прямо внутрь разметки с помощью фигурных скобок `{}`. Это позволяет динамически отображать данные или вычисления.

##### Пример вставки JavaScript в JSX:
```
const name = "Вася"
const element = <h1>Привет, {name}!</h1>;
```

В этом примере JSX использует значение переменной `name` и вставляет его в разметку.

##### Особенности JSX:
- В JSX нужно всегда использовать один корневой элемент. Например, если возвращается несколько элементов, их нужно обернуть в один элемент-контейнер, например, `<div>`, либо использовать React.Fragment (`<> ... </>`).
- Все теги в JSX должны быть закрыты. Например, одиночные теги должны иметь закрывающий слэш: `<img />`, `<input />`.

#### **Props (Свойства)**
`Props` — это способ передачи данных от родительского компонента к дочернему. Они позволяют компонентам быть динамическими и переиспользуемыми, поскольку каждый экземпляр компонента может получать разные данные.

Props передаются компонентам как параметры и являются неизменяемыми (read-only). Это означает, что компонент не может изменять свои `props`. Вместо этого их можно использовать только для отображения данных или передачи их дальше.

##### Пример использования props:
```
function Greeting(props) {
  return <h1>Hello, {props.name}!</h1>;
}

function App() {
  return (
    <div>
      <Greeting name="Alice" /> <Greeting name="Bob" />
    </div>
  );
}

export default App;
```

В этом примере:
- Компонент `Greeting` принимает `props` и использует свойство `name` для отображения имени.
- В компоненте `App` создается два экземпляра компонента `Greeting`, в которые передаются разные значения для свойства `name`.

##### Как работают Props:
1. **Передача данных от родителя к дочернему компоненту**. Родительский компонент передает данные в дочерний с помощью атрибутов, как в HTML.
2. **Дочерний компонент получает эти данные через объект `props`**. Каждый раз, когда компонент вызывается, `props` содержит все переданные данные.

##### Пример с несколькими props:

```
function Profile(props) {
  return (
    <div>
      <h1>{props.name}</h1> <p>Возраст: {props.age}</p>
      <p>Город: {props.city}</p>
    </div>
  );
}

function App() {
  return (
    <div>
      <Profile name="Alice" age={25} city="Москва" />
      <Profile name="Bob" age={30} city="Лондон" />
    </div>
  );
}
```

Здесь компонент `Profile` принимает три `props`: `name`, `age`, и `city`, и использует их для отображения профиля пользователя.

#### Дополнительные возможности Props:

1. **Props по умолчанию (default props)**: Если в компонент не переданы некоторые props, можно задать их значения по умолчанию.
```
function Greeting(props) {
  return <h1>Hello, {props.name}!</h1>;
}
Greeting.defaultProps = { name: 'Guest' };

или

function Greeting({name = 'Guest}) {
  return <h1>Hello, {name}!</h1>;
}
```
    
2. **Проверка типов props (prop-types)**: Для проверки типов данных, переданных через props, используется пакет `prop-types`.
```
import PropTypes from 'prop-types';
function Greeting(props) {
  return <h1>Hello, {props.name}!</h1>;
}
Greeting.propTypes = { name: PropTypes.string.isRequired };    
```
    
3. **Деструктуризация props**: Вместо использования объекта `props`, можно деструктурировать его прямо в аргументах функции, как показано выше
    
```
function Greeting({ name }) {
  return <h1>Hello, {name}!</h1>;
}
```